BY SUBMITTING THIS FILE TO CARMEN, I CERTIFY THAT I HAVE STRICTLY ADHERED
TO THE TENURES OF THE OHIO STATE UNIVERSITY’S ACADEMIC INTEGRITY POLICY
WITH RESPECT TO THIS ASSIGNMENT.

THIS IS THE README FILE FOR PROJECT 1.

Name: Harikeshav Rameshkumar
	
1.	UNIX is proprietary system (i.e. you must purchase a license) while Linux is an Open Source system.  An Open Source system, however, is not always “free”. Why?  
An Open Source system means that the source code is available for anyone to read, use, modify, and distribute under a license that complies with the Open Source definition. However, that doesn't mean that the software is required to be free of charge - there can be priced versions of Linux as well, as long as it includes the source code on distribution.

2.	Name another difference between Unix/Linux *from your required reading*. If you specify a difference that's not in the reading, it will be counted as incorrect.
The Linux kernel is Open Source and is developed by the Linux Community, while overseen by Linus Torvalds. However, the Unix kernel is proprietary and the three biggest distributions are Solaris (Oracle), AIX (IBM), and HP-UX Hewlett Packard.

3.	What made UNIX different from all other commercially available software systems when it was initially developed? Again, you must answer based on the content of the required reading, otherwise the answer will be counted as incorrect.
Unix only needed a small piece of special code (the kernel), which was the only code that needed to be adapted for every specific system. The operating system and all related functionality were built around this kernel, and thus could be run on any system that was capable of running a Unix kernel, allowing the development of an Operating System that could run on many different types of hardware.

4.	What operating system covers the widest range of hardware in the world?
Linux covers the widest range of hardware in the world.

5.	Why was the C programming language initially created? 
The C programming language was initially created in the early 1970s by Dennis Ritchie at Bell Labs. Its main purpose was to develop the UNIX operating system, which had originally been written in assembly language.

6.	What version of the mkdir command is running on stdlinux?  What mkdir option did you use to determine this?
mkdir (GNU coreutils) 8.30. The command used was `mkdir --version`

7.	What does the wc -l  instruction do?  The manual page for that instruction says prints the newline count, but what important information does that count tell you?
The instruction wc -l prints the newline count, and that tells you how many lines of text are in the input or file.

8.	Describe one difference between what you observed in the C programming language code in project1.c and either Java or C++ that you have used before.  Describe one similarity.
One difference between C and languages like Java or C++ is that C does not have built-in support for object-oriented programming features such as classes or inheritance. In C, functions are used to structure to organize code, whereas in Java or C++ you can create classes, define methods inside them, and use features like polymorphism and encapsulation directly. One similarity is the use of a similar syntax for things like loops, conditional statements, and function definitions. The general structure of a program that starts execution from a main function is also similar.

9.	How is white space (tabs/newlines/returns, spaces, etc.) handled within a C program file?  Do you think this “feature” of C program files is a good thing or a bad thing?  Why?
In a C program file, white space such as tabs, spaces, and newlines is generally ignored by the compiler except when it is used to separate tokens. This feature is a good thing because it gives the programmer flexibility to format code for readability without worrying about breaking functionality.

10.	When a line of code is printed out after the next command in gdb, that line of code has just finished executing.  True or False?
False

11.	Your task is to correct the 3 bugs in the program.  Answering the following questions may help you do that:

	a. What is the value of getchar_return_value at GDB item #4?  Is this what you expected to see?
If I entered the character '6', the value of getchar_return_value would be 54. No, because I was expecting the actual number 6, but after closely inspecting, this is expected because getchar() returns the integer ASCII value of the character read from the input stream, and 54 is the ASCII code for the character '6'.

	b. What is the value of maxEntries variable? How might the value change if maxEntries is more than one digit?
If you enter '6', the value of maxEntries becomes 54 because the code incorrectly assigns the ASCII value instead of the integer value. If you enter "10", maxEntries first becomes 49 (ASCII for '1'). Then, the flawed calculation 49 * 10 + '0' - '0' results in 490. Since maxEntries is a signed char, which only hold values up to 127, this value overflows and wraps around, resulting in a garbage value like -22.

	c. What were the hexadecimal values in the variable getchar_return_value as it read in each successive value from input?
When entering the number 10, the values were "0x31" for '1', "0x30" for '0', and "0x0a" for the newline character. 

	d. What is the relationship between the ASCII value of a digit and the actual value it represents?
The ASCII values for digits '0' through '9' are sequential. '0' is represented by ASCII code 48, '1' by 49, and so on up to '9' which is 57. To convert a digit character to its actual integer value, you subtract the ASCII value of '0', as their difference will be the actual integer difference between that number and 0.

12.  For each of the bugs you find, show what the original line of code looked like, then show how you changed it, this use 2-3 sentences to describe what you did within gdb to determine what the problem was.
	a. 
Original: char maxEntries;
Modified: int maxEntries;
The maxEntries variable was declared as a char, which can only hold values up to 127. This is insufficient and caused overflow errors as the value of MAX_NUM is 255, or if the user entered a value higher than 127. Changing it to an int makes the variable large enough to hold any practical number of entries.  In GDB, I could see the bug by attempting to manually set a large value (e.g., set var maxEntries = 200). Printing the variable showed that it "wraps around" to a negative number, thus letting me know that the char data type was too small for the intended range of values.

	b.
Original: maxEntries = getchar_return_value;
Modified: maxEntries = getchar_return_value - '0';
The program assigned the ASCII value of the first digit entered directly to maxEntries instead of converting it to an integer. This meant an input of '6' resulted in maxEntries being 54.  I set a breakpoint immediately after this line and ran the program with an input of 6. Using the print maxEntries command in GDB, the output was 54, confirming the value was the character's ASCII code rather than the number 6 I expected.

	c.
Original: maxEntries = maxEntries*10 + getchar_return_value - '0';
Modified: maxEntries = maxEntries*10 + (getchar_return_value - '0');
The formula to calculate a two-digit number was broken because it used the unconverted ASCII value of the first digit (stored in maxEntries from the previous buggy line). This resulted in an incorrect calculation (e.g., 49 * 10 instead of 1 * 10) that caused an overflow. By placing a breakpoint on this line and providing "10" as input, I first inspected maxEntries and saw it was 49 (ASCII for '1'). After stepping over the line, printing maxEntries again showed a garbage value like -22, which is the result of 490 overflowing a char, showing that the calculation was performed on the wrong initial value.

13.	If you used ddd instead of gdb, describe how you created the breakpoint in your program while using ddd instead of gdb.
N/A

14.	Edit the Makefile.  On the line that starts out "gcc_opt =" close to the top of the file,  put " -D DEBUG" (do not put the double quotes in the file).  Now say "touch project1.c".  Recompile the program and then rerun the program using 6 and banana.  Does the output change?  If so, how?
Yes, it did. It printed two extra lines: "entering function", and "returned from function".

15.	What do you think of the make command?  [2-3 sentences]
The make command is a powerful tool that makes it convenient to perform and automate build tasks for C projects. Since the make system just executes shell scripts, it can be adapted for creating build systems for any programming language, and not just C. It comes preinstalled in most Linux, macOS, and Unix-like system, thus the developer can be sure that it will always be available.
